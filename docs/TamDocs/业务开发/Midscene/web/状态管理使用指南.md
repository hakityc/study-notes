# Web 项目状态管理使用指南

本项目采用 **Zustand + TanStack Query** 组合方案进行状态管理。

## 📋 目录

- [技术栈](#技术栈)
- [目录结构](#目录结构)
- [Zustand 使用](#zustand-使用)
- [React Query 使用](#react-query-使用)
- [最佳实践](#最佳实践)

---

## 🛠 技术栈

### Zustand (客户端状态管理)

- **版本**: 5.0.8
- **用途**: 管理客户端 UI 状态、表单数据、用户配置等
- **特点**:
  - 极简 API，体积小（~1KB gzipped）
  - 无需 Provider 包裹
  - 支持持久化存储（localStorage）
  - TypeScript 完美支持

### TanStack Query (服务器状态管理)

- **版本**: 5.90.3
- **用途**: 管理服务器数据获取、缓存、同步
- **特点**:
  - 自动缓存和重新验证
  - 内置加载和错误状态
  - 请求去重和并发控制
  - 强大的 DevTools

---

## 📁 目录结构

```
src/
├── stores/                    # Zustand stores
│   ├── debugStore.ts         # Debug 页面状态
│   ├── promptStore.ts        # Prompt 优化页面状态
│   └── index.ts              # 统一导出
├── hooks/
│   ├── usePromptOptimizeApi.ts  # API hooks (React Query)
│   └── api/
│       └── index.ts          # API hooks 统一导出
├── providers/
│   ├── QueryProvider.tsx     # React Query Provider
│   └── index.ts
└── pages/                     # 页面组件
```

---

## 🎯 Zustand 使用

### 1. Store 定义

#### Debug Store 示例 (`debugStore.ts`)

```typescript
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface DebugState {
  // 状态
  endpoint: string;
  action: WebSocketAction;
  tasks: Task[];

  // Actions
  setEndpoint: (endpoint: string) => void;
  setAction: (action: WebSocketAction) => void;
  setTasks: (tasks: Task[]) => void;
}

export const useDebugStore = create<DebugState>()(
  persist(
    (set) => ({
      // 初始状态
      endpoint: 'ws://localhost:3000/ws',
      action: 'aiScript',
      tasks: [],

      // Actions
      setEndpoint: (endpoint) => set({ endpoint }),
      setAction: (action) => set({ action }),
      setTasks: (tasks) => set({ tasks }),
    }),
    {
      name: 'debug-storage',  // localStorage key
      partialize: (state) => ({  // 选择性持久化
        endpoint: state.endpoint,
        action: state.action,
        // tasks 不持久化
      }),
    },
  ),
);
```

### 2. 在组件中使用

```tsx
import { useDebugStore } from '@/stores';

function MyComponent() {
  // 选择性订阅需要的状态
  const endpoint = useDebugStore((state) => state.endpoint);
  const setEndpoint = useDebugStore((state) => state.setEndpoint);

  // 或者批量获取
  const { action, setAction, tasks, setTasks } = useDebugStore();

  return (
    <div>
      <input
        value={endpoint}
        onChange={(e) => setEndpoint(e.target.value)}
      />
    </div>
  );
}
```

### 3. 性能优化

```tsx
// ✅ 好：只订阅需要的字段
const endpoint = useDebugStore((state) => state.endpoint);

// ❌ 不好：订阅整个 store（每次更新都会重新渲染）
const store = useDebugStore();
```

### 4. 复杂更新逻辑

```tsx
// 在 store 中定义复杂的更新逻辑
const useDebugStore = create<DebugState>()((set, get) => ({
  // ...

  // 复杂更新
  loadHistory: (item: HistoryItem) => {
    const { tasks } = get();  // 获取当前状态
    set({
      action: item.message.payload.action,
      tasks: [...tasks, ...item.tasks],
    });
  },
}));
```

---

## 🌐 React Query 使用

### 1. API Hook 定义

```typescript
// hooks/usePromptOptimizeApi.ts
import { useMutation } from '@tanstack/react-query';

interface OptimizeParams {
  prompt: string;
  targetAction: string;
}

const optimizePrompt = async (params: OptimizeParams) => {
  const response = await fetch('/api/prompt-optimize', {
    method: 'POST',
    body: JSON.stringify(params),
  });
  return response.json();
};

export function usePromptOptimizeApi() {
  return useMutation({
    mutationFn: optimizePrompt,
    onSuccess: (data) => {
      console.log('优化成功:', data);
    },
    onError: (error) => {
      console.error('优化失败:', error);
    },
  });
}
```

### 2. 在组件中使用 Mutation

```tsx
import { usePromptOptimizeApi } from '@/hooks/usePromptOptimizeApi';

function MyComponent() {
  const { mutate, isPending, isError, isSuccess, data } = usePromptOptimizeApi();

  const handleOptimize = () => {
    mutate(
      { prompt: 'test', targetAction: 'aiTap' },
      {
        onSuccess: (data) => {
          // 成功回调
          console.log(data);
        },
        onError: (error) => {
          // 错误回调
          console.error(error);
        },
      }
    );
  };

  return (
    <div>
      <button onClick={handleOptimize} disabled={isPending}>
        {isPending ? '优化中...' : '开始优化'}
      </button>
      {isError && <p>优化失败</p>}
      {isSuccess && <p>优化成功: {data.optimized}</p>}
    </div>
  );
}
```

### 3. Query (GET 请求) 示例

```typescript
// hooks/useTemplatesApi.ts
import { useQuery } from '@tanstack/react-query';

const fetchTemplates = async () => {
  const response = await fetch('/api/templates');
  return response.json();
};

export function useTemplatesApi() {
  return useQuery({
    queryKey: ['templates'],  // 唯一标识
    queryFn: fetchTemplates,
    staleTime: 1000 * 60 * 5,  // 5 分钟内不重新获取
    gcTime: 1000 * 60 * 10,     // 10 分钟后清除缓存
  });
}

// 使用
function MyComponent() {
  const { data, isLoading, isError, refetch } = useTemplatesApi();

  if (isLoading) return <div>加载中...</div>;
  if (isError) return <div>加载失败</div>;

  return (
    <div>
      {data.map(template => <div key={template.id}>{template.name}</div>)}
      <button onClick={() => refetch()}>刷新</button>
    </div>
  );
}
```

---

## 💡 最佳实践

### 1. 状态管理分工

| 状态类型 | 使用方案 | 示例 |
|---------|---------|------|
| UI 状态 | Zustand | 模态框开关、表单输入、选项卡选择 |
| 表单数据 | Zustand | 未提交的表单、草稿 |
| 用户配置 | Zustand | 主题、语言、偏好设置 |
| 服务器数据 | React Query | API 数据、列表、详情 |
| 异步操作 | React Query | POST/PUT/DELETE 请求 |

### 2. Store 设计原则

```typescript
// ✅ 好：每个页面/模块独立的 store
useDebugStore
usePromptStore
useSettingsStore

// ❌ 不好：全局大 store
useGlobalStore (包含所有状态)

// ✅ 好：扁平化状态
{
  inputPrompt: string;
  outputPrompt: string;
}

// ❌ 不好：过度嵌套
{
  form: {
    prompts: {
      input: string;
      output: string;
    }
  }
}
```

### 3. 持久化策略

```typescript
persist(
  (set) => ({ /* ... */ }),
  {
    name: 'storage-key',
    partialize: (state) => ({
      // 只持久化需要的字段
      theme: state.theme,
      language: state.language,
      // 不持久化临时状态
      // isLoading: state.isLoading,
    }),
  }
)
```

### 4. React Query 缓存策略

```typescript
// 实时数据：短缓存时间
useQuery({
  queryKey: ['live-data'],
  staleTime: 0,  // 立即过期
  gcTime: 1000 * 30,  // 30 秒后清除
});

// 静态数据：长缓存时间
useQuery({
  queryKey: ['static-data'],
  staleTime: Infinity,  // 永不过期
  gcTime: Infinity,  // 永不清除
});

// 常规数据：适中缓存
useQuery({
  queryKey: ['normal-data'],
  staleTime: 1000 * 60 * 5,  // 5 分钟
  gcTime: 1000 * 60 * 10,  // 10 分钟
});
```

### 5. 错误处理和降级

```typescript
const handleOptimize = () => {
  mutate(params, {
    onError: (error) => {
      // 后端失败时降级到本地逻辑
      const fallbackResult = localOptimize(params);
      setResult(fallbackResult);
    },
  });
};
```

### 6. 组合使用示例

```tsx
function SmartComponent() {
  // Zustand: 管理 UI 状态
  const { inputValue, setInputValue } = useFormStore();

  // React Query: 管理服务器请求
  const { mutate, isPending } = useSubmitApi();

  const handleSubmit = () => {
    mutate(
      { value: inputValue },
      {
        onSuccess: () => {
          setInputValue('');  // 清空表单
        },
      }
    );
  };

  return (
    <>
      <input
        value={inputValue}
        onChange={(e) => setInputValue(e.target.value)}
      />
      <button onClick={handleSubmit} disabled={isPending}>
        提交
      </button>
    </>
  );
}
```

---

## 📚 参考资源

- [Zustand 官方文档](https://docs.pmnd.rs/zustand/getting-started/introduction)
- [TanStack Query 官方文档](https://tanstack.com/query/latest)
- [Zustand 中文文档](https://awesomedevin.github.io/zustand-vue/docs/introduce/what-is-zustand)

---

## 🔧 调试工具

### Zustand DevTools

```typescript
import { devtools } from 'zustand/middleware';

const useDebugStore = create<DebugState>()(
  devtools(
    persist(
      (set) => ({ /* ... */ }),
      { name: 'debug-storage' }
    ),
    { name: 'DebugStore' }  // DevTools 中显示的名称
  )
);
```

### React Query DevTools

```tsx
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';

<QueryProvider>
  <App />
  <ReactQueryDevtools initialIsOpen={false} />
</QueryProvider>
```

---

## 🎉 总结

- ✅ **Zustand** 用于客户端状态，简单高效
- ✅ **React Query** 用于服务器状态，功能强大
- ✅ 两者配合使用，职责清晰
- ✅ 持久化和缓存策略明确
- ✅ 性能优化和错误处理完善

Happy Coding! 🚀
