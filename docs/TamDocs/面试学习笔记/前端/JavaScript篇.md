# JavaScript篇

> 本篇主要记录了一些关于Kimi模拟JS面试的内容[对话链接](https://kimi.moonshot.cn/chat/ct76emu9e5jm5q2954j0)。
>
> prompt :
参考这个<https://www.yuque.com/cuggz/interview/vgbphi>  ，请你作为面试官 ，向我提问，请你根据一定的逻辑向我逐个提问，请你从第一个问题开始逐个提问，在我答完之后，请你：以md的格式记录一份针对该问题简短好记的概括，而且要包含： （回答的内容 、答错的内容、漏答的内容、总结） 四个无序列表。

## 第1题：`typeof null` 的结果是什么，为什么？

- **答错的内容：**
  - 无
- **漏答的内容：**
  - 为什么 `typeof null` 返回 `"object"`。
- **正确内容总结：**
  - `typeof null` 的结果是 `"object"`。这是因为在早期的JavaScript规范中，`null` 被错误地归类为 `"object"` 类型，尽管这个设计在后来的规范中被纠正，但为了保持向后兼容性，`typeof null` 返回 `"object"` 的行为被保留下来。

## 第2题：`Array.isArray()` 方法的作用是什么？

- **答错的内容：**
  - 无
- **漏答的内容：**
  - `Array.isArray()` 是ES5中引入的方法，并且它不会受到对象原型链的影响。
- **正确内容总结：**
  - `Array.isArray()` 用于判断一个对象是否为数组。

## 第3题：JavaScript中有哪些数组的遍历方法？

- **答错的内容：**
  - `for...in` 用于遍历对象的属性，而不是数组。
- **漏答的内容：**
  - 除了 `for...of` 和 `forEach`，还有其他数组遍历方法，如 `for` 循环、`map`、`filter`、`reduce`、`some` 和 `every`。
- **正确内容总结：**
  - `for...of` 用于遍历数组中的每个元素；`forEach` 是数组的方法，用于对数组中的每个元素执行一次提供的函数。

## 第4题：JavaScript中的`this`指向是如何确定的？

- **答错的内容：**
  - `this` 并不总是指向父级，它的指向是由函数的调用方式决定的。
- **漏答的内容：**
  - `this` 的指向有多种情况，包括作为对象方法调用、构造函数调用、作为独立函数调用、使用 `call`、`apply`、`bind` 方法调用等。
- **正确内容总结：**
  - 箭头函数中的 `this` 指向是固定的，它继承自外围最近一层非箭头函数的 `this` 绑定。

## 第5题：解释JavaScript中的原型继承机制

- **答错的内容：**
  - `__proto__` 是对象内部属性的一个非标准属性，且原型继承不仅仅是在声明对象时建立的。
- **漏答的内容：**
  - 原型继承的核心是每个对象都有一个内部链接指向另一个对象，称为其原型；原型链的查找过程。
- **正确内容总结：**
  - 每个对象都有一个内部属性 `[[Prototype]]`（在大多数现代浏览器中可以通过 `__proto__` 访问），这个属性指向该对象的原型。

## 第7题：解释JavaScript中的`Promise`是什么，以及它的三种状态

- **答错的内容：**
  - `Promise` 不是宏任务，而是一个用来异步执行代码的对象。
- **漏答的内容：**
  - `Promise` 的三种状态的详细解释：`pending`、`fulfilled` 和 `rejected`。
- **正确内容总结：**
  - `Promise` 是一个代表异步操作的对象，它有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。

## 第8题：解释JavaScript中的`var`、`let`和`const`关键字的区别

- **答错的内容：**
  - `var` 声明的变量不仅限于全局变量。
- **漏答的内容：**
  - `var` 的变量提升和函数提升；`let` 和 `const` 的暂时性死区。
- **正确内容总结：**
  - `var` 声明的变量具有函数作用域或全局作用域，存在变量提升；`let` 和 `const` 声明的变量具有块级作用域，不存在变量提升，存在暂时性死区。

## 问题9：解释JavaScript中的事件冒泡和事件捕获

- **回答的内容：**

  - 事件冒泡是因为HTML是树形结构，子元素的行为会逐级响应到父级元素。
  - 事件捕获是父级元素对事件的响应。
  - 常用于树形结构元素，例如树形下拉框。

- **答错的内容：**

  - 事件捕获描述不准确，事件捕获是从父级元素向子元素传播，而不是父级对子元素的响应。

- **漏答的内容：**

  - 未提及事件冒泡和事件捕获的具体过程和三个阶段：捕获阶段、目标阶段和冒泡阶段。
  - 未详细说明事件冒泡和事件捕获在实际开发中的其他应用场景。

- **总结：**

  - **事件冒泡**：当在HTML文档中的元素上触发事件时，如果该事件不被捕获，则会一直冒泡到根节点。这个过程称为事件冒泡。
    - **正确**：描述了事件冒泡的基本过程。
    - **错误**：未提及事件冒泡的具体阶段和详细过程。
  - **事件捕获**：事件捕获是事件处理机制的第一阶段，事件从文档根节点开始，一直向下传播到目标节点。
    - **正确**：提到了事件捕获的概念。
    - **错误**：描述不准确，事件捕获不是父级对子元素的响应，而是事件从根节点向目标节点传播的过程。
  - **应用场景**：
    - **事件冒泡**：常用于实现事件委托，例如处理一组按钮的点击事件。
    - **事件捕获**：较少直接使用，但在需要在事件到达目标元素之前进行拦截或处理时有用，例如，日志记录或权限检查。
    - **树形结构**：事件冒泡和捕获都适用于树形结构的UI组件，如树形菜单，可以用于管理节点的展开和折叠。

## 问题10：描述JavaScript中的深浅拷贝及其区别

- **回答的内容：**
  - 深拷贝是将整个对象复制，包括对象内部的所有属性。
  - 浅拷贝只复制对象的引用地址，不复制对象内部的属性。
  - 浅拷贝一般是在函数传参时使用。
  - 深拷贝用于需要复制整个对象的场景。

- **答错的内容：**
  - 描述中提到“浅拷贝针对的是基础数据类型和对象的引用地址”，这个描述不完全准确，因为浅拷贝实际上是复制对象的引用地址，而不是基础数据类型的值。

- **漏答的内容：**
  - 未提及深拷贝和浅拷贝的具体实现方法（例如使用 `Object.assign()`、展开运算符 `...`、`JSON.parse(JSON.stringify(obj))` 等）。
  - 未详细说明深拷贝和浅拷贝在实际开发中可能遇到的问题，如循环引用、函数和undefined的拷贝问题等。

- **总结：**
  - **浅拷贝**：
    - 只复制对象的第一层属性，对象内部的属性仍然是引用。
    - 常用于函数参数传递，避免修改原始对象。
    - 实现方法包括 `Object.assign()` 和展开运算符 `...`。
  - **深拷贝**：
    - 完全复制一个对象，包括对象内部的所有属性，不共享引用。
    - 用于需要独立复制整个对象结构的场景。
    - 实现方法包括 `JSON.parse(JSON.stringify(obj))` 和第三方库如 `lodash` 的 `_.cloneDeep()` 方法。
  - **区别**：
    - 浅拷贝不会复制对象内部的属性，而深拷贝会复制对象的所有层级。
    - 浅拷贝速度快，深拷贝速度慢，且有局限性（如不能复制函数和循环引用）。
  - **应用场景**：
    - **浅拷贝**：适用于不需要复制对象内部属性的场景，或者需要保持对象内部属性引用的场景。
    - **深拷贝**：适用于需要完全独立复制对象的场景，如配置对象的复制。

## 问题11：解释JavaScript中的原型链是什么以及它是如何工作的

- **回答的内容：**
  - 原型链是由各个对象对其自身原型的指向所构成的链形结构。
  - 声明一个对象时会将其绑定到该构造函数的原型链上。
  - 从Object开始，逐渐往下沿着原型链有各种各样的对象。

- **答错的内容：**
  - 描述中提到“声明一个对象时会将其绑定到该构造函数的原型链上”可能会造成误解，实际上每个对象都隐式地链接到一个原型对象，而这个原型对象可能是某个构造函数的prototype属性。

- **漏答的内容：**
  - 未提及原型链的具体查找机制，即属性和方法的查找过程。
  - 未说明原型链的终点是`Object.prototype`，其原型为`null`。
  - 未提及原型链在继承和属性查找中的应用。

- **总结：**
  - **原型链概念**：
    - 原型链是JavaScript中对象继承和属性查找的机制，每个对象都有一个指向其原型的内部链接（`__proto__` 或 `Object.getPrototypeOf()`）。
    - **正确**：提到了对象对自身原型的指向构成的链形结构。
    - **错误**：更准确的描述是对象通过内部链接指向其原型，而不是绑定到构造函数的原型链上。
  - **原型链的终点**：
    - 原型链的终点是`Object.prototype`，其原型为`null`。
    - **遗漏**：未提及这一点，这是原型链的重要特性。
  - **原型链的应用**：
    - 原型链用于实现继承和属性查找，当访问一个对象的属性时，如果该对象本身没有这个属性，JavaScript引擎会沿着原型链向上查找，直到找到该属性或到达原型链的末端。
    - **遗漏**：未提及这一点，这是原型链的核心应用。

## 问题12：解释JavaScript中的异步编程及其相关模式

- **回答的内容：**
  - 回调函数是在执行函数后等待其回调，并可能在回调函数中进行其他操作，这可能导致“回调地狱”。
  - Promise用来解决“回调地狱”问题，有三种状态：reject、fulfilled、pending，存在then和catch方法。
  - async/await是Promise的语法糖，让异步代码像同步代码一样编写，提高可读性，但也要求父级函数也必须是async的以保持同步性。

- **答错的内容：**
  - 无

- **漏答的内容：**
  - 未提及Promise构造函数和Promise.prototype.then、Promise.prototype.catch的详细用法。
  - 未说明async/await在错误处理上与Promise的关系。
  - 未提及async/await如何转换为Promise。

- **总结：**
  - **回调函数**：
    - 用于处理异步操作完成后的回调，但可能导致“回调地狱”，即多层嵌套的回调函数。
    - **正确**：描述了回调函数的概念和可能导致的问题。
  - **Promise**：
    - 用来解决“回调地狱”，有三种状态：pending、fulfilled、rejected，提供了then和catch方法处理异步操作的结果。
    - **正确**：概述了Promise的基本功能和状态。
  - **async/await**：
    - 是Promise的语法糖，使得异步代码可以像同步代码一样编写，提高代码的可读性。
    - **正确**：说明了async/await的作用和基本要求。
    - **补充**：async函数内部的异步操作默认返回Promise，错误处理需要使用try/catch。
  - **注意事项**：
    - 使用async/await时，如果函数中有await表达式，则整个函数会返回一个Promise。
    - 错误处理方面，async函数中使用try/catch可以捕获到await执行期间抛出的错误。

## 问题13：解释闭包在JavaScript中的作用及其应用场景

- **回答的内容：**
  - 闭包是函数和其外部资源的总和。
  - 应用场景包括截流防抖和hook。

- **答错的内容：**
  - “截流防抖”和“hook”并不是闭包的直接应用，而是闭包可能被用于实现这些功能的技术。

- **漏答的内容：**
  - 未详细解释闭包的定义，即闭包能够访问其创建时的作用域链中的变量。
  - 未提供具体的代码示例来说明闭包的工作方式。
  - 未提及闭包的其他常见应用场景，如创建私有变量、模块化封装等。

- **总结：**
  - **闭包的定义**：
    - 闭包是一个函数和其周围状态（词法环境）的组合，使得函数能够访问其创建时的作用域中的变量，即使函数在其作用域之外被调用。
      - **正确**：提到了闭包是函数和外部资源的总和，但描述不够准确和全面。
  - **闭包的应用场景**：
    - **数据封装和私有化**：闭包可以用来创建私有变量，这些变量只能在闭包内部访问。
    - **函数工厂**：使用闭包可以创建返回函数的函数，这些返回的函数可以有不同的行为。
    - **模块化**：闭包可以用来创建模块，封装和隐藏内部状态和函数。
    - **防抖和节流**：闭包可以用来实现防抖和节流功能，这两种技术常用于控制事件处理函数的执行频率。
    - **Hook**：在某些情况下，闭包可以用于实现hook模式，如在React中使用useEffect等。
      - **错误**：将“截流防抖”和“hook”直接作为闭包的应用是不准确的，它们是闭包可能参与实现的技术。

## 问题14：解释JavaScript中的IIFE（立即调用的函数表达式）是什么，以及它的用途

- **回答的内容：**
  - 不清楚IIFE的具体含义和用途。

- **答错的内容：**
  - 无

- **漏答的内容：**
  - IIFE的定义和结构。
  - IIFE如何创建一个新的作用域。
  - IIFE在模块化、封装私有变量和函数等方面的应用。

- **总结：**
  - **IIFE定义**：
    - IIFE是立即调用的函数表达式，它是一种JavaScript模式，允许函数在定义后立即执行。
    - **补充**：IIFE通常写成`(function() { /* code */ })();`的形式，其中`(function() { /* code */ })`是一个匿名函数表达式，后面的`()`表示立即调用这个函数。
  - **IIFE结构**：
    - IIFE可以带参数，也可以返回值，这使得它在某些场景下非常有用。
    - **补充**：例如，`(function(a, b) { return a + b; })(1, 2);`会返回`3`。
  - **创建新作用域**：
    - IIFE通过创建一个新的作用域来避免污染全局作用域，这有助于模块化和封装。
    - **补充**：在IIFE内部定义的变量不会泄漏到全局作用域中，这有助于防止命名冲突。
  - **应用场景**：
    - **模块化**：IIFE可以用来创建独立的模块，每个模块都有自己的私有作用域。
    - **封装**：IIFE可以用来封装私有变量和函数，只在内部使用。
    - **依赖注入**：IIFE允许将依赖作为参数传递，这有助于测试和维护代码。
  - **好处**：
    - 使用IIFE可以避免全局变量的冲突，特别是在大型项目中。
    - IIFE还可以用于创建设计模式，如工厂模式和单例模式。

## 问题15：描述JavaScript中的事件循环（Event Loop）机制

- **回答的内容：**
  - JavaScript事件分为同步任务和异步任务，异步任务分为宏任务和微任务。
  - 在加载后，JavaScript首先按上下文顺序执行所有的同步任务，并将宏任务和微任务放到各自的队列。
  - 在同步任务执行完成后，继续执行宏任务，然后执行微任务。
  - 事件循环指的是重复这一个过程。

- **答错的内容：**
  - 无

- **漏答的内容：**
  - 未提及事件循环中宏任务和微任务的具体示例。
  - 未详细解释事件循环与调用栈、任务队列之间的关系。
  - 未提及浏览器和Node.js环境在事件循环实现上的差异。

- **总结：**
  - **事件循环基本概念**：
    - JavaScript的事件循环确保代码的单线程运行，通过管理同步任务和异步任务的执行顺序。
    - **正确**：概述了同步任务和异步任务的基本分类。
  - **任务分类**：
    - 异步任务进一步分为宏任务（如setTimeout、setInterval、I/O、UI渲染）和微任务（如Promise.then/catch/finally、MutationObserver）。
    - **正确**：提到了宏任务和微任务的区分。
  - **执行顺序**：
    - 同步任务首先执行，然后是宏任务，最后是微任务。
    - **正确**：描述了任务的基本执行顺序。
  - **事件循环过程**：
    - 事件循环不断检查调用栈和任务队列，执行可执行的任务，直到它们为空。
    - **正确**：说明了事件循环重复执行任务队列中的任务。
  - **环境差异**：
    - 浏览器和Node.js环境有不同的事件循环实现，例如Node.js的事件循环包括多个阶段，每个阶段都可以执行不同的任务。
    - **补充**：了解不同环境下的事件循环实现有助于深入理解JavaScript的异步行为。

## 问题17：解释JavaScript中的`Symbol`类型及其用途

- **回答的内容：**
  - 不清楚`Symbol`的具体含义和用途。

- **答错的内容：**
  - 无

- **漏答的内容：**
  - `Symbol`是ES6中新增的数据类型，代表创建后独一无二的且不可变的数据类型。
  - `Symbol`主要用于解决全局变量冲突的问题，提供一种方式来创建唯一的属性键。
  - `Symbol`可以作为对象属性的键，使得属性名不会冲突。
  - `Symbol`是原始值，不是对象，因此不能添加属性。

- **总结：**
  - **`Symbol`定义**：
    - `Symbol`是一种新的原始数据类型，用于创建唯一的不可变值。
    - **补充**：`Symbol`是ES6中引入的，用于确保对象属性的键值唯一性。
  - **`Symbol`用途**：
    - **解决全局变量冲突**：`Symbol`可以作为对象属性的键，确保属性名不会冲突。
    - **创建唯一属性键**：`Symbol`作为对象的键，可以保证每个键都是唯一的，避免命名冲突。
    - **私有属性**：在类中使用`Symbol`可以创建私有属性，这些属性不会被继承。
    - **迭代不可枚举**：使用`Symbol`作为对象属性的键，该属性不会出现在`for...in`、`Object.keys()`等迭代操作中。
  - **`Symbol`特点**：
    - `Symbol`是原始值，不是对象，因此不能添加属性。
    - `Symbol`值是唯一的，即使两个`Symbol`看起来相同，它们也是不同的。
    - `Symbol`可以作为对象属性的键，但不能作为数组索引。
