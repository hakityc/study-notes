# 面试思考框架

## STAR-R 通用思考框架

---

### S - 确认问题（Scenario Clarification）

- **请求复述**："您的问题是问...对吗？"
- **明确边界**：确认问题范围（是否限制技术栈/场景/特殊要求）  
  示例：问虚拟滚动实现时，需确认是否要手写代码还是口述原理

---

### T - 问题拆解（Technical Breakdown）

- **核心知识点**：快速定位问题涉及的技术领域  
  例如：
  - [事件循环题] → 调用栈/微任务/宏任务/渲染时序  
  - [性能优化题] → 网络层/渲染层/计算层优化  

- **技术分层**：将问题拆解为「浏览器原理 + 语言特性 + 框架机制」的组合  
  （如 Vue 响应式问题 = `Object.defineProperty` / `Proxy` + 依赖收集 + 组件更新机制）

---

### A - 递进回答（Answer with Depth）

1. **基础层**：先给出标准答案（体现知识储备）  
   示例："HTTP 缓存可分为强缓存（Expires/Cache-Control）和协商缓存（Last-Modified/ETag）..."
2. **原理层**：延伸到底层机制（展示技术深度）  
   示例："Webpack 的 HMR 本质是通过 WebSocket 建立热更新通道，由 chunk 比对生成补丁文件..."
3. **实践层**：结合项目经验（增强说服力）  
   示例："我们在首屏优化时通过 Resource Hint 预加载关键资源，使 LCP 时间从 3.2s 降至 1.8s"

---

### R - 异常处理（Risk Control）

- **容错方案**：给出备选方案和降级策略  
  示例："当 `IntersectionObserver` 不兼容时，可用 `scroll` 事件 + 节流 + 元素位置计算代替"
- **调试技巧**：展示问题排查能力  
  示例："内存泄漏问题可通过 Chrome Memory 面板做堆快照对比，观察 `Detached DOM` 节点"

---

### R - 反思扩展（Retrospect & Extend）

- **技术选型对比**  
  示例："Vue3 改用 Proxy 的优势在于能检测到深层属性变化，但也存在浏览器兼容性代价"
- **延伸思考**  
  示例："这种方案在 SSR 场景下需要额外考虑注水过程中的状态同步问题"

---

## 高频题型应对策略

### **▨ 概念原理题**（如：事件循环 / 作用域链）

1. 标准定义  
2. 执行流程图解  
3. 实际场景示例  
4. 常见误区  

### **▨ 手写实现题**（如：Promise / 防抖）

1. 功能需求分析  
2. 测试用例设计  
3. 基础实现  
4. 边界处理  
5. 性能优化  

### **▨ 场景设计题**（如：大文件上传）

1. 需求分析（断点续传 / 进度展示 / 错误重试）  
2. 技术方案选型（分片策略 / 并发控制 / 校验机制）  
3. 核心代码伪实现  
4. 异常处理方案  

### **▨ 框架原理题**（如：React Hooks 原理）

1. 常规用法  
2. 核心实现机制（链表存储 / 执行顺序）  
3. 设计理念对比（与 class 组件的差异）  
4. 最佳实践  

---

## 救场技巧（遇到卡壳时）

- **渐进式思考**："这个问题我需要分三步考虑，首先...然后..."
- **合理示弱**："这部分底层实现我了解有限，但根据经验判断可能是..."
- **转移焦点**："虽然具体 API 记不清，但解决这类问题的一般思路是..."
- **逆向验证**："假设我们采用方案 A，可能遇到的问题是..."

---

## **加分项设计**

- **技术视野**：提到 W3C 标准提案 / TC39 新特性  
- **工程意识**：强调可维护性（TS 类型定义 / 单元测试）  
- **业务敏感**：结合真实数据（"在用户留存率提升 2% 的场景中..."）  

> **建议配合使用「3C 法则」**：
>
> - **Confidence（自信表达）**
> - **Code（代码佐证）**
> - **Case（案例支撑）**

## **最后提醒**

面试后立即记录陌生问题，建立自己的 **「面试错题本」**。
