# 小程序面试题

<script setup lang="ts">
    import AnswerBlock from '@/components/common/answer-block.vue'
</script>

## 说说你对微信小程序的理解？优缺点？

<AnswerBlock >

**理解**：  
微信小程序是2017年推出的轻量级应用，运行于微信内部，实现“触手可及、用完即走”的体验。基于浏览器内核重构，结合原生API和JS-SDK，提供接近原生的性能和权限。

**优点**：  

- 无需安装，随搜随用  
- 依托微信生态流量大  
- 开发门槛低，兼容性强  
- 安全性高  

**缺点**：  

- 用户留存率低（平均次日留存1%）  
- 代码包体积限制（2M）  
- 功能受限于微信平台规则  
- 安卓端灵活性弱于原生APP  

</AnswerBlock>

## 小程序的生命周期函数有哪些？

<AnswerBlock >

**应用生命周期**（app.js）：  

- `onLaunch`：初始化完成（全局仅一次）  
- `onShow`：小程序显示（包括冷启动和热启动）  
- `onHide`：小程序进入后台  
- `onError`：未捕获异常  
- `onPageNotFound`：页面不存在  

**页面生命周期**（page.js）：  

| 生命周期   | 说明                     | 典型用途               |
|------------|--------------------------|------------------------|
| `onLoad`   | 页面加载（带参数）       | 初始化数据             |
| `onShow`   | 页面显示                 | 更新状态               |
| `onReady`  | 首次渲染完成             | 获取页面元素           |
| `onHide`   | 页面隐藏                 | 清理定时器/音频        |
| `onUnload` | 页面卸载                 | 清理资源               |

**组件生命周期**（component.js）：  

- `created`：组件实例创建  
- `attached`：组件进入页面节点树  
- `ready`：组件渲染完成  
- `detached`：组件脱离页面节点树  
- `error`：组件方法抛出错误  

**页面级生命周期**（pageLifetimes）：  

- `show`：组件所在页面显示  
- `hide`：组件所在页面隐藏  

</AnswerBlock>

## 小程序的登录流程是怎样的？

<AnswerBlock >

**核心流程**：  

1. **获取code**：调用`wx.login()`获取临时登录凭证  
2. **换取openid/session_key**：  
   - 前端将code发送至服务器  
   - 服务器调用微信接口（`appid + appsecret + code`）  
   - 微信返回`openid`（用户唯一标识）和`session_key`（加密密钥）  
3. **生成自定义登录态**：  
   - 服务器生成3rd_session（需满足：长度≥16位、强随机、有效期）  
   - 将3rd_session与openid关联存储  
4. **存储登录态**：前端将3rd_session存入`wx.setStorageSync`  
5. **校验登录态**：  
   - 每次请求携带3rd_session  
   - 服务器验证有效性  

**扩展机制**：  

- 使用`wx.checkSession()`检测微信登录态是否过期  
- 过期时重新执行完整登录流程  

</AnswerBlock>

## 微信小程序中路由跳转的方式有哪些？区别？

<AnswerBlock >

**跳转方式**：  

1. **`wx.navigateTo`**：保留当前页，跳转到非tabBar页面（可返回）  
2. **`wx.redirectTo`**：关闭当前页，跳转到非tabBar页面（不可返回）  
3. **`wx.switchTab`**：跳转到tabBar页面，关闭其他非tabBar页面  
4. **`wx.navigateBack`**：返回上一页（可通过`delta`控制返回层数）  
5. **`wx.reLaunch`**：关闭所有页面，打开指定页面  

**区别对比**：  

| 方式          | 页面栈变化                     | 是否保留当前页 | 是否支持tabBar |
|---------------|--------------------------------|----------------|----------------|
| navigateTo    | 新页面入栈                     | 是             | 否             |
| redirectTo    | 当前页出栈，新页面入栈         | 否             | 否             |
| switchTab     | 清空非tabBar页面栈，切换tab    | 否             | 是             |
| navigateBack  | 按delta层数出栈                 | 否             | 否             |
| reLaunch      | 清空所有页面栈，新页面入栈     | 否             | 是/否          |

</AnswerBlock>

## 微信小程序的发布流程是怎样的？

<AnswerBlock >

**标准流程**：  

1. **上传代码**：  
   - 开发者工具点击“上传”，填写版本号和备注  
   - 代码包提交至微信公众平台  

2. **提交审核**：  
   - 在“开发管理”中选择版本，填写审核信息（功能描述、截图等）  
   - 腾讯审核团队进行合规性检查  

3. **发布版本**：  
   - 审核通过后，在“开发管理”中点击“发布”  
   - 新版本会在24小时内全量覆盖用户  

**企业级优化**：  

- 使用自动化构建工具（如Jenkins）实现CI/CD  
- 分支管理（master分支仅用于发布）  
- 灰度发布（分阶段放量）  

</AnswerBlock>

## 微信小程序的支付流程是怎样的？

<AnswerBlock >

**核心步骤**：  

1. **用户下单**：  
   - 小程序调用`wx.login()`获取code  
   - 提交订单信息（商品、金额等）至服务器  

2. **服务器处理**：  
   - 调用微信支付接口（`统一下单API`）  
   - 微信返回`prepay_id`（预支付交易会话ID）  

3. **调起支付**：  
   - 小程序调用`wx.requestPayment`，传入以下参数：  

     ```javascript
     {
       timeStamp: '时间戳',
       nonceStr: '随机字符串',
       package: 'prepay_id=xxx',
       signType: 'HMAC-SHA256',
       paySign: '签名'
     }
     ```  

4. **支付结果处理**：  
   - 微信支付控件返回结果（成功/失败）  
   - 服务器接收微信异步通知（`支付结果回调API`）  
   - 更新订单状态  

**安全注意事项**：  

- `session_key`和`prepay_id`禁止传输到客户端  
- 支付签名需在服务器端生成  
- 使用HTTPS保证通信安全  

</AnswerBlock>

## 小程序的双线程架构是怎样的？

<AnswerBlock >

**架构设计**：  

- **逻辑层**：运行于`JsCore`线程，处理业务逻辑和数据  
- **渲染层**：运行于`WebView`线程，负责UI渲染和交互  

**通信机制**：  

- **数据绑定**：通过`setData`将逻辑层数据同步到渲染层  
- **事件处理**：用户交互事件通过`Native`桥转发到逻辑层  

**性能特点**：  

- 双线程并行提升响应速度  
- 数据通信存在延迟（需合理设计异步逻辑）  
- 首屏渲染需等待逻辑层数据  

**生命周期协同**：  

- 逻辑层`onLoad` → 渲染层初始化 → 逻辑层`onReady`  

</AnswerBlock>

## 如何提高小程序的启动速度？

<AnswerBlock >

**优化策略**：  

1. **代码包体积控制**：  
   - 使用分包加载（主包≤2M，子包按需加载）  
   - 图片/资源网络加载代替本地存储  
   - 开启代码压缩（开发者工具勾选“压缩代码”）  

2. **预加载技术**：  
   - 配置`subpackages`预下载可能访问的子包  
   - 使用`wx.preloadSubpackages`主动预加载  

3. **首屏渲染优化**：  
   - 骨架屏占位减少白屏时间  
   - 使用`setStorageSync`缓存常用数据  
   - 避免在`onLoad`中执行复杂逻辑  

4. **渲染性能优化**：  
   - 合并多次`setData`为单次调用  
   - 避免在`data`中存储非渲染数据  
   - 使用自定义组件减少页面节点更新范围  

**其他建议**：  

- 避免使用`eval`等阻塞主线程的操作  
- 合理使用`wx.showLoading`提示加载状态  

</AnswerBlock>
